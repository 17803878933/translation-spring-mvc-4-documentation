<h1 id="21-5-1-viewresolver-">21.5.1 使用ViewResolver接口解析视图</h1>
<p>正如在<a href="http://docs.spring.io/spring-framework/docs/4.2.4.RELEASE/spring-framework-reference/html/mvc.html#mvc-controller" title="21.3 Implementing Controllers">21.3 控制器的实现</a>一节中所讨论的，Spring MVC中所有控制器的处理器方法都必须返回一个逻辑视图的名字，无论是显式返回（比如返回一个<code>String</code>、<code>View</code>或者<code>ModelAndView</code>）还是隐式返回（比如基于约定的返回）。Spring中的视图由一个视图名标识，并由视图解析器来渲染。Spring有非常多内置的视图解析器。下表列出了大部分，表后也给出了一些例子。</p>
<p><strong>表21.3 视图解析器</strong></p>
<table>
<thead>
<tr>
<th>视图解析器</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AbstractCachingViewResolver</code></td>
<td>一个抽象的视图解析器类，提供了缓存视图的功能。通常视图在能够被使用之前需要经过准备。继承这个基类的视图解析器即可以获得缓存视图的能力。</td>
</tr>
<tr>
<td><code>XmlViewResolver</code></td>
<td>视图解析器接口<code>ViewResolver</code>的一个实现，该类接受一个XML格式的配置文件。该XML文件必须与Spring XML的bean工厂有相同的DTD。默认的配置文件名是<code>/WEB-INF/views.xml</code>。</td>
</tr>
<tr>
<td><code>ResourceBundleViewResolver</code></td>
<td>视图解析器接口<code>ViewResolver</code>的一个实现，采用bundle根路径所指定的<code>ResourceBundle</code>中的bean定义作为配置。一般bundle都定义在classpath路径下的一个配置文件中。默认的配置文件名为<code>views.properties</code>。</td>
</tr>
<tr>
<td><code>UrlBasedViewResolver</code></td>
<td><code>ViewResolver</code>接口的一个简单实现。它直接使用URL来解析到逻辑视图名，除此之外不需要其他任何显式的映射声明。如果你的逻辑视图名与你真正的视图资源名是直接对应的，那么这种直接解析的方式就很方便，不需要你再指定额外的映射。</td>
</tr>
<tr>
<td><code>InternalResourceViewResolver</code></td>
<td><code>UrlBasedViewResolver</code>的一个好用的子类。它支持内部资源视图（具体来说，Servlet和JSP）、以及诸如<code>JstlView</code>和<code>TilesView</code>等类的子类。You can specify the view class for all views generated by this resolver by using <code>setViewClass(..)</code>。更多的细节，请见<code>UrlBasedViewResolver</code>类的java文档。</td>
</tr>
<tr>
<td><code>VelocityViewResolver</code> / <code>FreeMarkerViewResolver</code></td>
<td><code>UrlBasedViewResolver</code>下的实用子类，支持Velocity视图<code>VelocityView</code>（Velocity模板）和FreeMarker视图<code>FreeMarkerView</code>以及它们对应子类。</td>
</tr>
<tr>
<td><code>ContentNegotiatingViewResolver</code></td>
<td>视图解析器接口<code>ViewResolver</code>的一个实现，它会根据所请求的文件名或请求的<code>Accept</code>头来解析一个视图。更多细节请见<a href="http://docs.spring.io/spring-framework/docs/4.2.4.RELEASE/spring-framework-reference/html/mvc.html#mvc-multiple-representations" title="21.5.4 ContentNegotiatingViewResolver">21.5.4 内容协商视图解析器&quot;ContentNegotiatingViewResolver&quot;</a>一小节。</td>
</tr>
</tbody>
</table>
<p>我们可以举个例子，假设这里使用的是JSP视图技术，那么我们可以使用一个基于URL的视图解析器<code>UrlBasedViewResolver</code>。这个视图解析器会将URL解析成一个视图名，并将请求转交给请求分发器来进行视图渲染。</p>
<pre><code class="lang-xml">&lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;&gt;
    &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>若返回一个<code>test</code>逻辑视图名，那么该视图解析器会将请求转发到<code>RequestDispatcher</code>，后者会将请求交给<code>/WEB-INF/jsp/test.jsp</code>视图去渲染。</p>
<p>如果需要在应用中使用多种不同的视图技术，你可以使用<code>ResourceBundleViewResolver</code>：</p>
<pre><code class="lang-xml">&lt;bean id=&quot;viewResolver&quot;
        class=&quot;org.springframework.web.servlet.view.ResourceBundleViewResolver&quot;&gt;
    &lt;property name=&quot;basename&quot; value=&quot;views&quot;/&gt;
    &lt;property name=&quot;defaultParentView&quot; value=&quot;parentView&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p><code>ResourceBundleViewResolver</code>会检索由bundle根路径下所配置的<code>ResourceBundle</code>，对于每个视图而言，其视图类由<code>[viewname].(class)</code>属性的值指定，其视图url由<code>[viewname].url</code>属性的值指定。下一节将详细讲解视图技术，你可以在那里找到更多例子。你还可以看到，视图还允许有基视图，即properties文件中所有视图都“继承”的一个文件。通过继承技术，你可以为众多视图指定一个默认的视图基类。</p>
<blockquote>
<p><code>AbstractCachingViewResolver</code>的子类能够缓存已经解析过的视图实例。关闭缓存特性也是可以的，只需要将<code>cache</code>属性设置为<code>false</code>即可。另外，如果实在需要在运行时刷新某个视图（比如修改了Velocity模板时），你可以使用<code>removeFromCache(String viewName, Locale loc)</code>方法。`</p>
</blockquote>
